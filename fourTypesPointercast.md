# question：为什么需要四种类型的强制类型转换
# answer：
指针指示了一段内存的起始地址，类型告诉了计算机如何去理解这段数据。很多时候我们需要对同一段数据有不同的理解，所以需要类型转换。
如一个指针，通过指针我们可以访问一段内存，但是我们有时候也想知道一个指针具体指向的空间的位置，所以需要将指针转化为 int 型。
但是我们需要知道这种类型转换是否是正确的，如一个浮点数转为指针类型，是没有意义的。
## 1：原本的类型转换的缺点
    如果没有强制类型转换，那么C++程序中的类型转换将遵从C语言中的类型转换模式，有如下两种
    1：隐式转换
        int  a = 3;
        float b= a;
        这一种由编译器自行判断类型之间是否能转换，如果能转则转，如果不能转，编译器就会报错。
        这种转换是有风险的，首先，类型之间的转换是编译器自动执行的，有可能程序员没有发现，会带来一些未知的隐患，另外不同类型隐式转换，可能会有精度损失
    2：显示转换
        int a = 1234；
        int* b = &a;
        int p = (int) b;
        这种是显式转换，可读性较差，所有的类型转换都是一种形式，难以跟踪错误。
    
## 2：现在C++中引入四种强制类型转换取代原本的C语言类型转换，将原本的转换转化为更明确的方式，程序员知道发生了什么样的转换，避免隐患，同时可读性更强
    1：static_cast用于编译时的类型转换，正如它的名字static所显示的那样，会在编译时候检查类型检查的正确性。
    主要用于基本类型之间的转换。如将 int 转化为 float，以及派生类向基类的转换，也可以用于基类指针向派生类指针的转换，但是不安全。

    2：dynamic_cast 用于执行时的类型转换，主要用于类层次之间的类型转换，如派生类指针向基类指针的转换或者是基类向派生类指针的转换。
    由于dynamic_cast 转换的时候需要使用运行时类型信息RTTI，而在编译期是没有这个信息的。

    static_cast  和 dynamic_cast 对比
    (1):进行类型转换的时期不同，一个是编译时，一个是运行时
    (2):均可以进行基类与派生类指针之间的转换，但是static_cast将派生类指针转为基类指针是安全的，将基类指针转为派生类是不安全的，因为不知道派生类相比于基类内存空间有什么变化，但是编译不会报错，程序可以执行，但是可能会导致未定义行为，导致程序崩溃。
    (3):dynamic_cast 在进行类的不同层次指针转换时候，会依赖于类运行时类型信息RTTI，这也是它名字的由来。
    dynamic_cast会根据RTTI来判断是指针类型强转是否安全，如果不安全，会返回nullptr或者是引用类型之间的转换，如果不安全，会抛出异常。
    所以使用 dynamic_cast 时候需要增加，异常处理

    3：const_cast 
    const_cast<type>(expression)
    该运算符用来修改 expression 的 const 或 volatile 属性。这里需要注意：expression 和 type 的类型一样的，也就是只能将int const 转化为 int
    
    如 const int a  =1;
    int b = a; // 这样会报错，因为const也是类型中的一部分
    int c = const_cast<int>(a) //这样就没有问题 

    volatile 属性同理
    4：reinterpret_cast
    int main()
    {
        int* p = new int(5);
        uint64_t p_val = reinterpret_cast<uint64_t>(p);

        cout << "p    :" << p << endl;
        cout << "p_val:" << hex << p_val << endl;

        return 0;
    }
    这是最危险的一种类型转换，可以进行任意类型的转换，且没有检查，不会报错，容易导致未定义行为

## 3：总结
    1：static_cast 主要用于基本类型的转换，编译时进行转换，检查，假如发现是无关类型之间的转换，会报错，不能通过编译。
    也可以用于基类指针与派生类指针的转换，由派生类指向基类是安全的，但是由基类指针指向派生类指针时候，也可以通过编译，但是此时没有RTTI信息，所有不能保证派生类指针向基类指针的转换是否正确，所以是不安全的，容易导致未定义行为

    2：dynamic_cast 主要用于类的不同层次之间的转换，在运行时进行转换，需要检查RTTI信息，检查是否转换正确，所以相对安全。在运行时进行，所以可能相对耗时。

    3：const_cast 主要用于去除类型的const 属性 和volatile属性

    4：reinterpret_cast 没有任何限制与检查，最危险，容易出现未定义行为，谨慎使用。


    

